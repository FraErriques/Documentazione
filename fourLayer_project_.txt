Four Layer Project structure
---------------------------------------

This kind of project structure is thought for Business-Logic, especially when the application logic is 
determined by a relational database. In this scenario, one of the layers is devoted to mirror the database entities
in the application. Such layer is called "Entity". In general the model involves a class for each db-table. Such class represents a single record, i.e. a sigle row. For the vector representation of an array of them, there's another class, with the prefix "insertionManager", which loops on the rows and instantiates the homologous Entity at each loop-step.
The four layers are:

	-	Common
	-	Entity
	-	Process
	-	Interface

The first one, Common, is a low-level utility layer; it contains services such as sockets for db-connections, logging in varous forms, cryptography, singleton-template, international calendars, etc. In general this layer is
totally reusable across projects, since none of its code depends on the business logic; it rather depends on machine level characteristics, as db-connections, etc. The existence of this code enables the developer to start directly from the business logic, having the "Common" part for granted.

The second one is the Entity, which is a db-Entity. All of the table-mirror-classes and storedProcedure Proxies are developed here. For its nature, it can reach any necessary level of complexity. But the usage of its classes will be  simplified by another layer, where the complexity is boxed and presented via self explanatory static functions. Let's think that a particular Enity-usage requires the instantiation of nested templates. The Entity can surely host such complexity, but the interface-user will not need to understand all of it. The boxing is the purpose of next level, called Process.

The support-layer is called Process and is as simple as static functions, with self-explanatory names like do_this_thing(). The interface programmer will be able to link a complicated action to a graphic-button or to a command-line instruction, via a call to Process::do_this_thing(). The body of the Process::do_this_thing() function
will contain the complexity of the required actions, to access the Entity::classes and let them work.

Last layer is the user-interface, which is just any kind of interface suitable for the purpose. Its typical purpose is to translate user actions, such as buttons or command lines, to calls to Process::do_this_thing().

In projects of Numerical Analisys there's in general no db layer. There are many specific algorithms, like Runge-kutta, Simpson, etc. In that scenario the project stack can become something like this:

   -	    Common
   -	    RealAnalysis
   -	    ComplexAnalisys
   -	    DifferentialEquations
   -	    Integrate
   -	    ....
   -	    Process
   -	    Interface

in this scenario the layers {Common, Process, Interface} are the same as in the case of a business logic. The db-Entity instead is substituted by a set of algorithms, specific to the pursued purposes. There can though be an Entity layer, in case some of the numerical data are stored there; an example may be the dump of RungeKutta, or similar scatters. But it's important a separation between the database-layer and the Numerical-Analysis modules. The ideal sets could be like: {RealAnalysis,ComplexAnalysis,LinearAlgebra,..} for the Algorithmic portion and a classical {Entity} for the database access of any kind; probably some of the computational modules will have to log data( such as point scatters, or other) on the db. The algorithms will be in the computational modulus which might compute a matrix, multiplying or inverting some other matrices, and the resulting matrix will be written in the db by means of a proxy in the Entity-layer, which calls a stored procedure of the db.

...to be continued
TODO use BrikoJ solution (i.e. Project-group) to realize this architecture and develop frmCalendar in Java.

